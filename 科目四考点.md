 ​​UML图核心考点总结​​
​​一、用例图（Use Case Diagram）考点​​
​​1. 四种关系辨析​​
关系类型
表示法
考点说明
经典示例
​​关联关系​​
———
参与者与用例之间的基本关系
[顾客] ——— (下单)
​​包含关系​​
———>《include》
​​必须执行​​的关系，基础用例依赖被包含用例
(下单) ———>《include》 (验证库存)
不下单也要验证库存？不可能！
​​扩展关系​​
———>《extend》
​​有条件执行​​的关系，基础用例独立存在
(支付) ———>《extend》 (使用优惠券)
支付可以不使用优惠券
​​泛化关系​​
——▷
​​父子继承​​关系，子用例继承父用例所有行为
(支付) ◁—— (信用卡支付)
(支付) ◁—— (支付宝支付)
​​2. 易错点​​
​​包含vs扩展​​：包含是​​必须的​​，扩展是​​可选的​​
​​参与者泛化​​：[VIP用户] ——▷ [普通用户]，VIP用户具备普通用户所有功能
​​二、类图（Class Diagram）考点精华​​
​​1. 六种关系深度解析​​
​​(1) 依赖关系（Dependency）​​ -------→
​​语义​​：​​临时性的使用​​，方法参数、局部变量、静态方法调用
​​代码表现​
​
class Teacher {
    public void correctHomework(Homework homework) { // 方法参数
        Pen pen = new Pen(); // 局部变量
        pen.grade(homework);
    }
}
class Homework { }
class Pen { }


​​UML​​：Teacher -------→ Homework，Teacher -------→ Pen
​​(2) 关联关系（Association）​​ ————→
​​语义​​：​​长期持有的引用​​，成员变量级别的关系
​​代码表现​​

class Student {
    private School school; // 成员变量，长期存在
    private List<Course> courses; // 1对多关联
}
class School { }
class Course { }


​​UML​​：Student ————→ School，Student ————→ Course
​​多重性​​：1(1个)，*(多个)，0..1(0或1个)，1..*(至少1个)
​​(3) 聚合关系（Aggregation）​​ ————◊
​​语义​​：​​整体与部分可分离​​，部分可以独立于整体存在
​​经典示例​​

class Computer {
    private List<USBDevice> usbDevices; // U盘可以插到不同电脑
}
class USBDevice { }


​​UML​​：Computer ◊————→ USBDevice
​​记忆口诀​​：​​弱拥有​​，部分生命周期独立
​​(4) 组合关系（Composition）​​ ————◆
​​语义​​：​​整体与部分同生共死​​，部分不能独立于整体存在
​​经典示例​​

class House {
    private Room livingRoom;  // 房间不能脱离房子存在
    private Room bedroom;
    public House() {
        this.livingRoom = new Room(); // 同时创建
        this.bedroom = new Room();
    }
}
class Room { }


​​UML​​：House ◆————→ Room
​​记忆口诀​​：​​强拥有​​，同生共死
​​(5) 泛化关系（Generalization）​​ ————▷
​​语义​​：​​继承关系​​，is-a关系
​​代码表现​​

class Animal { }
class Dog extends Animal { } // Dog is a Animal
class Cat extends Animal { } // Cat is a Animal


​​UML​​：Dog ————▷ Animal，Cat ————▷ Animal
​​(6) 实现关系（Realization）​​ - - - -▷
​​语义​​：​​接口实现​​
​​代码表现​​

interface Flyable { void fly(); }
class Bird implements Flyable { public void fly() { } }
class Airplane implements Flyable { public void fly() { } }


​​UML​​：Bird - - - -▷ Flyable，Airplane - - - -▷ Flyable
​​2. 关系强度对比（考点！）​​
​​依赖 < 关联 < 聚合 < 组合​<泛化=实现​
关系
生命周期依赖
代码表现
依赖
无
方法内部临时使用
关联
无
成员变量引用
聚合
弱
成员变量，可独立存在
组合
强
成员变量，同生共死
​​3. 易混淆关系辨析​​
​​聚合vs组合​​：
​​聚合​​场景​​：
一个汽车制造厂（CarFactory）使用引擎（Engine）来组装汽车（Car）。引擎由专门的引擎工厂（EngineFactory）生产。
​
// 引擎类
class Engine {
    private String model;
    public Engine(String model) { this.model = model; }
}

// 汽车类
class Car {
    private String name;
    private Engine engine; // 汽车拥有一个引擎（聚合关系）

    // 关键点：引擎是从外部传入的，不是由汽车创建的
    public Car(String name, Engine engine) {
        this.name = name;
        this.engine = engine; // 组装现有的引擎
    }
}

// 使用场景
public class Main {
    public static void main(String[] args) {
        // 1. 先独立创建引擎
        Engine v8Engine = new Engine("V8");
        
        // 2. 将已有的引擎安装到汽车上
        Car car1 = new Car("宝马", v8Engine);
        
        // 3. 同一个引擎可以被安装到另一辆汽车上（理论上）
        // Car car2 = new Car("奥迪", v8Engine); 
        
        // 4. 汽车报废时，引擎可以被拆下继续使用
        car1 = null; // 汽车销毁
        // 但 v8Engine 对象仍然存在，可以被其他汽车使用
    }
}
 
 
​
UML表示​​：Car ◊————→ Engine
​​关系特点​​：
部分（Engine）的生命周期独立于整体（Car）
整体通过参数接收部分对象（外部创建）
部分可以被多个整体共享（理论上）
​​组合​场景：​一个公司（Company）由多个部门（Department）组成。部门不能独立于公司存在。
// 部门类
class Department {
    private String name;
    public Department(String name) { this.name = name; }
}

// 公司类
class Company {
    private String name;
    private Department hrDepartment;     // 人力资源部
    private Department itDepartment;     // 技术部

    // 关键点：部门是在公司构造函数内部创建的
    public Company(String name) {
        this.name = name;
        // 公司创建时，同时创建所属的部门
        this.hrDepartment = new Department("人力资源部");
        this.itDepartment = new Department("信息技术部");
    }

    // 当公司解散时，部门也随之解散
    public void bankrupt() {
        // 清理部门资源
        this.hrDepartment = null;
        this.itDepartment = null;
    }
}

// 使用场景
public class Main {
    public static void main(String[] args) {
        // 创建公司时，自动创建其部门
        Company company = new Company("阿里巴巴");
        
        // 无法独立创建"阿里巴巴的人力资源部"
        // Department hr = new Department("人力资源部"); // 这个部门不属于任何公司
        
        // 当公司解散时，部门自动解散
        company.bankrupt();
        // 对应的 hrDepartment 和 itDepartment 也随之失效
    }
}
 
 
​​UML表示​​：Company ◆————→ Department
​​关系特点​​：
部分（Department）的生命周期完全依赖于整体（Company）
整体负责创建部分对象（内部创建）
部分专属于特定的整体，不能共享
​
​​依赖vs关联​​：
​​依赖​​：teacher.correctHomework(homework)（临时参数）
​​关联​​：student.school（长期持有）
​
三、活动图（Activity Diagram）​​
​​1. 定义与目的​​
​​定义​​：描述业务过程或操作的工作步骤，类似于流程图
​​目的​​：建模业务流程、用例的具体实现、复杂算法
​​2. 核心元素​​
元素
表示法
说明
开始节点
●
流程的开始
活动节点
圆角矩形
执行的具体活动
控制流
箭头
活动之间的转移
决策节点
菱形
条件分支判断
合并节点
菱形
分支合并
分叉/汇合
粗黑线
并行活动的开始/结束
结束节点
◎
流程的结束
​​3. 绘制步骤​​
​​确定起止点​​：标识流程的开始和结束
​​列出活动​​：按顺序列出所有活动节点
​​添加分支​​：识别决策点和并行活动
​​连接流程​​：用控制流连接所有元素
​​4. 最佳实践​​
每个活动应该有明确的输入输出
避免过于复杂的嵌套判断
并行活动要明确分叉和汇合点
保持主要流程在中心线上
​​5. 典型示例​​

开始 → 登录系统 → [验证成功?] → 是 → 进入主页 → 结束
                    ↓
                    否 → 显示错误 → 返回登录


​​四、顺序图（Sequence Diagram）​​
​​1. 定义与目的​​
​​定义​​：显示对象之间动态的协作关系，强调时间顺序
​​目的​​：描述用例的详细实现，分析对象间的消息传递
​​2. 核心元素​​
元素
表示法
说明
对象生命线
矩形+虚线
对象的生存周期
激活条
细长矩形
对象执行操作的时间段
同步消息
实线箭头
等待返回的调用
异步消息
虚线箭头
不等待返回的调用
返回消息
虚线箭头
方法调用的返回
创建/销毁
箭头+×
对象的创建和销毁
​​3. 绘制步骤​​
​​识别参与对象​​：确定交互中的所有对象
​​排列对象​​：按交互顺序从左到右排列
​​绘制消息​​：按时间顺序从上到下添加消息
​​添加激活期​​：标识方法的执行时间段
​​处理循环/条件​​：使用组合片段表示复杂逻辑
​​4. 最佳实践​​
重要对象放在左侧
保持消息的合理粒度
使用组合片段处理分支循环
关注核心业务流，避免细节过度
​​5. 典型示例​​

用户 → 控制器: 提交订单()
控制器 → 服务层: 验证订单()
服务层 → DAO: 保存订单()
DAO → 数据库: insert操作
数据库 → DAO: 返回结果
DAO → 服务层: 返回成功
服务层 → 控制器: 返回订单ID
控制器 → 用户: 显示成功页面


​​五、状态图（State Diagram）​​
​​1. 定义与目的​​
​​定义​​：描述对象所有可能的状态以及事件发生时状态的转移条件
​​目的​​：建模具有明确状态变化的复杂对象行为
​​2. 核心元素​​
元素
表示法
说明
状态
圆角矩形
对象在生命周期中的状况
转移
箭头
状态之间的转换
初始状态
●
状态的起点
终止状态
◎
状态的终点
事件
箭头标签
触发转移的条件
动作
状态内部
状态进入/退出时执行的操作
​​3. 绘制步骤​​
​​识别状态​​：找出对象的所有可能状态
​​确定初始/终止状态​​：标识开始和结束状态
​​识别转移​​：分析状态之间如何转换
​​定义事件​​：确定触发转移的事件和条件
​​添加动作​​：定义进入/退出状态时的操作
​​4. 最佳实践​​
状态命名使用形容词或过去分词
避免状态爆炸，适当抽象
明确每个转移的触发条件
关注重要的状态变化
​​5. 典型示例​​

订单状态图：
[初始] → 待支付 --支付成功→ 已支付 --发货→ 已发货 --确认收货→ 已完成
                  ↓                     ↓
                  取消                 退款申请
                  ↓                     ↓
                已取消                退款中 --退款完成→ 已关闭


📊 ​​各UML图适用场景总结​​
UML图类型
主要用途
使用阶段
​​用例图​​
需求分析，功能规划
需求阶段
​​类图​​
系统静态结构设计
设计阶段
​​活动图​​
业务流程建模
分析/设计阶段
​​顺序图​​
对象交互时序分析
设计阶段
​​状态图​​
复杂对象行为建模
设计阶段

--------------------------------------------------------------------------



创建型模式
1. Factory Method（工厂方法）
​​实例​​：
​​日志记录器​​：一个抽象基类 Logger定义了 log(message)方法。它有多个具体子类：FileLogger, ConsoleLogger, DatabaseLogger。Logger类中有一个 GetLogger()的工厂方法，由子类去决定是创建文件日志器还是控制台日志器。应用程序只需要调用 Logger logger = Logger.GetLogger();而无需关心具体类型。
​​适用情况​​：
当一个类无法预知它必须创建的对象的类时。
当你希望将产品的创建过程委托给子类，希望子类来决定具体创建哪种对象时。
需要隔离具体类与客户端代码，使代码更易于扩展（添加新的产品类型只需新增子类）。
2. Abstract Factory（抽象工厂）
​​实例​​：
​​UI 组件库​​：有一个抽象工厂 GUIFactory，它声明了创建一组相关UI组件的方法：createButton(), createCheckbox()。有两个具体工厂：WindowsFactory和 MacFactory。WindowsFactory创建的是 Windows 风格的按钮和复选框，而 MacFactory创建的是 macOS 风格的。应用程序根据操作系统选择使用哪个工厂，从而确保整个应用程序的UI风格一致。
​​适用情况​​：
系统需要独立于其产品的创建、组合和表示方式。
系统需要配置多个产品族中的一个（如 Windows/Mac 主题）。
需要强调一系列相关的产品对象（属于同一个家族）一起使用，以确保一致性。
3. Builder（建造者）
​​实例​​：
​​构造一个复杂的 HTML 文档​​：HTMLDocument对象非常复杂，有很多可选的组成部分（标题、元标签、正文、多个脚本等）。直接通过构造函数创建会很臃肿。我们可以定义一个 HTMLDocumentBuilder，它提供了像 setTitle(title), addMetaTag(tag), addBodySection(section)等方法，最后有一个 getResult()方法来返回构建好的完整文档。Director类可以指导构建过程（即调用 Builder 方法的顺序模板）。
​​适用情况​​：
创建复杂对象，其创建算法（组装步骤）应该独立于该对象的组成部分。
构造过程必须允许被构造的对象有不同的表示（例如，构建一个房子，可以是木屋也可以是石头城堡，但建造步骤大同小异）。
4. Prototype（原型）
​​实例​​：
​​游戏中的敌人生成​​：一个游戏中有多种敌人（兽人、精灵、巨龙），每种敌人都是一个复杂的对象，有自己的模型、血量、攻击力等属性。与其每次需要生成敌人时都 new一个并重新设置所有属性，不如预先创建好一个“原型”对象。当需要新敌人时，就通过克隆（复制）这个原型对象来创建，然后可能微调一下位置等属性。这比直接创建效率高很多。
​​适用情况​​：
当需要创建的对象实例化过程很昂贵或很复杂时（例如，需要从数据库加载数据）。
当系统应该独立于产品的创建、构成和表示时，并且要实例化的类是在运行时指定的。
避免构建与产品层次结构平行的工厂层次结构。
5. Singleton（单例）
​​实例​​：
​​数据库连接池​​：一个应用程序通常只需要一个数据库连接池来管理所有的数据库连接。这个连接池需要被整个应用程序共享。使用单例模式可以确保任何地方获取到的都是同一个连接池实例，避免了资源冲突和浪费。
​​配置管理器​​：应用程序的配置信息（如文件路径、系统参数）只需要被加载一次，并且全局可访问。配置管理器很适合做成单例。
​​适用情况​​：
类只能有一个实例，并且必须为客户提供一个访问该实例的全局访问点。
​​注意​​：单例模式在测试中可能带来问题（因为全局状态），在现代依赖注入框架普及后，其使用需谨慎。
结构型模式
6. Adapter Class/Object（适配器）
​​实例​​：
​​兼容旧接口​​：你有一个新的图形绘制库，它有一个 Draw()方法。但你的旧代码中大量使用了另一个遗留图形库，它的绘制方法是 display()。你可以创建一个适配器类，继承或引用这个新库的类，然后在适配器中实现旧的 display()接口，并在其内部调用新的 Draw()方法。
​​适用情况​​：
你想使用一个已经存在的类，而它的接口不符合你的需求。
你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。
7. Bridge（桥接）
​​实例​​：
​​图形和绘图API​​：有 Shape（图形）抽象类和 Circle, Rectangle等子类。同时，有不同的绘图API，如 DrawingAPI接口，有 V1Drawing（用于旧系统）和 V2Drawing（用于新系统）两个实现。如果不使用桥接，你需要 V1Circle, V2Circle, V1Rectangle, V2Rectangle四个类。使用桥接，你让 Shape包含一个 DrawingAPI的引用。这样，Circle和 Rectangle就与具体的绘图API实现解耦了，可以自由组合。
​​适用情况​​：
你不希望在抽象和实现部分之间有固定的绑定关系（例如，希望在运行时切换实现）。
类的抽象和实现都应该可以通过继承进行扩展。
对一个实现的修改不应该对客户端产生影响，即客户端的代码不需要重新编译。
8. Composite（组合）
​​实例​​：
​​文件系统​​：文件系统中有文件和文件夹。文件夹可以包含文件或其他文件夹。你可以定义一个 FileSystemComponent接口，它有 getSize()等方法。File和 Folder都实现这个接口。对于 Folder的 getSize()方法，它会遍历所有子组件（文件或子文件夹）并求和。这样，客户端可以统一地对待单个文件和整个文件夹。
​​适用情况​​：
你想表示对象的“部分-整体”层次结构。
你希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象。
9. Decorator（装饰）
​​实例​​：
​​Java I/O 流​​：FileInputStream是一个基础组件，用于读取文件字节。BufferedInputStream是一个装饰器，它包装另一个 InputStream，为其添加了缓冲功能。LineNumberInputStream是另一个装饰器，它包装一个 InputStream，为其添加了行号计数功能。你可以动态地组合这些功能：new LineNumberInputStream(new BufferedInputStream(new FileInputStream("test.txt")))。
​​适用情况​​：
在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
当不能通过继承扩展功能时（比如，类被标记为 final，或者需要给大量独立的对象添加功能，继承会导致子类爆炸）。
10. Facade（外观）
​​实例​​：
​​启动电脑​​：启动一台电脑需要调用 CPU、内存、硬盘等多个部件的启动方法。对用户来说，这个流程太复杂。我们可以创建一个 Computer外观类，它提供一个简单的 start()方法。在 start()方法内部，它按正确的顺序调用所有内部部件的初始化方法。用户只需调用 computer.start()即可。
​​适用情况​​：
要为复杂的子系统提供一个简单的接口。
客户端和抽象的实现类之间存在很多依赖关系。使用外观模式可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。
11. Flyweight（享元）
​​实例​​：
​​文本编辑器中的字符​​：一个文档中有成千上万个字符，每个字符都有字体、大小、颜色等内在状态（可共享），以及它在文档中的位置（行、列）等外在状态（不可共享）。享元模式会为每个唯一的字符样式（如 ‘A’+宋体+12号+红色）创建一个享元对象并缓存起来。当需要渲染时，将位置信息作为参数传递给享元对象。这极大地减少了内存占用。
​​适用情况​​：
一个应用程序使用了大量的对象。
由于使用大量对象，造成很大的存储开销。
对象的大多数状态都可以变为外部状态（即不依赖于对象自身标识的状态）。
12. Proxy（代理）
​​实例​​：
​​图片懒加载​​：一个网页中有很多大图片。直接加载所有图片会很慢。可以创建一个 ImageProxy对象来代替真实的图片对象。当网页绘制时，ImageProxy先显示一个占位图。只有当用户滚动到图片可见区域时，ImageProxy才去真正加载硬盘上的大图片，然后用真实的图片对象替换自己。
​​适用情况​​：
​​远程代理​​：为一个对象在不同的地址空间提供局部代表。
​​虚代理​​：根据需要创建开销很大的对象（如上例）。
​​保护代理​​：控制对原始对象的访问，用于对象应该有不同的访问权限的时候。
行为型模式
13. Interpreter（解释器）
​​实例​​：
​​正则表达式​​：正则表达式引擎就是一个解释器。它解释执行你定义的正则表达式语法规则，来匹配字符串。SQL 解析、数学公式计算器等也常用此模式。
​​适用情况​​：
当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时。
该模式效率可能不是最高，通常用于一些相对简单的语法。
14. Template Method（模板方法）
​​实例​​：
​​数据处理的框架​​：一个抽象类 DataProcessor定义了一个算法骨架：readData() -> processData() -> writeData()。其中 processData()被声明为抽象方法。子类 CSVProcessor和 DatabaseProcessor分别继承它，并实现自己的 readData()和 writeData()（如果需要），但共用父类的 processData流程。这确保了所有数据处理流程的一致性。
​​适用情况​​：
一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。
各个子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
15. Chain of Responsibility（责任链）
​​实例​​：
​​Web 框架的过滤器/拦截器​​：一个 HTTP 请求需要经过认证、日志记录、权限检查、压缩等多个处理环节。可以创建一个过滤器链。每个过滤器都持有下一个过滤器的引用。一个过滤器处理完请求后，可以决定是继续传递给下一个过滤器，还是直接返回响应。这样就解耦了发送者和多个接收者。
​​适用情况​​：
有多个对象可以处理一个请求，哪个对象处理该请求在运行时自动确定。
你想在不明确指定接收者的情况下，向多个对象中的一个提交请求。
16. Command（命令）
​​实例​​：
​​文本编辑器的撤销/重做​​：用户的每个操作（输入文字、删除、加粗）都被封装成一个命令对象（如 InsertCommand, DeleteCommand）。每个命令对象都实现了 execute()和 unexecute()方法。当用户执行操作时，调用 execute()并将该命令存入历史列表。当用户撤销时，从历史列表中取出最后一个命令并调用其 unexecute()方法。
​​适用情况​​：
需要将请求调用者和请求接收者解耦。
需要支持命令的排队、记录日志、撤销/重做等操作。
17. Iterator（迭代器）
​​实例​​：
​​Java 的 Collection 框架​​：List, Set等集合类都提供了 iterator()方法来返回一个迭代器。客户端不需要关心集合底层是数组还是链表，只需要通过迭代器的 hasNext()和 next()方法就可以遍历所有元素。
​​适用情况​​：
需要访问一个聚合对象的内容而无需暴露它的内部表示。
支持对聚合对象的多种遍历。
为遍历不同的聚合结构提供一个统一的接口。
18. Mediator（中介者）
​​实例​​：
​​图形用户界面（GUI）对话框​​：一个对话框中有按钮、文本框、复选框等多个组件。例如，选择一个复选框可能会使某个文本框变为可用/禁用；点击一个按钮可能需要读取多个文本框的内容。如果让每个组件都直接引用其他组件，会形成复杂的网状依赖。中介者模式引入一个 DialogDirector中介者，所有组件只与中介者通信，由中介者来协调组件之间的交互。
​​适用情况​​：
一组对象以定义良好但复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。
一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。
19. Memento（备忘录）
​​实例​​：
​​游戏存档​​：游戏角色有生命值、魔法值、位置等状态。在某个时间点，你可以创建一个备忘录对象（存档文件），将角色的当前状态保存进去。当游戏失败时，你可以从备忘录对象中恢复角色的状态（读档）。
​​适用情况​​：
必须保存一个对象在某一时刻的状态，以便以后需要时能够恢复到先前的状态。
如果用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。
20. Observer（观察者）
​​实例​​：
​​消息队列、事件监听​​：一个气象站主题（Subject）在温度、湿度等数据变化时，会通知所有注册的观察者（如当前状况布告板、天气预报布告板、统计布告板）。每个布告板（观察者）在接收到通知后，会拉取最新的数据并更新自己的显示。
​​适用情况​​：
当一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时。
一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
21. State（状态）
​​实例​​：
​​TCP 连接​​：一个 TCP 连接可以处于多种状态（已建立 Established，监听 Listening，关闭 Closed）。当收到一个请求（如 open, acknowledge, close）时，连接对象会根据其当前状态做出不同的反应，并可能转移到新的状态。使用状态模式，将为每个状态创建一个类，每个状态类自己处理在其状态下的行为。
​​适用情况​​：
一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。
一个操作中含有庞大的多分支条件语句，且这些分支依赖于该对象的状态。
22. Strategy（策略）
​​实例​​：
​​支付方式​​：一个电商网站的结账系统需要支持多种支付策略（支付宝 AlipayStrategy、微信支付 WechatPayStrategy、信用卡 CreditCardStrategy）。这些策略都实现一个共同的 Pay(amount)接口。结账时，根据用户的选择，传入不同的策略对象给上下文对象，即可调用相应的支付算法。
​​适用情况​​：
许多相关的类仅仅是行为有异。策略模式提供了一种用多个行为中的一个行为来配置一个类的方法。
需要使用一个算法的不同变体。
23. Visitor（访问者）
​​实例​​：
​​编译器语法树分析​​：有一个由多种节点类型（赋值节点 AssignmentNode、变量引用节点 VariableRefNode）组成的抽象语法树。你需要对这颗树进行多种不同的操作（类型检查 TypeCheckingVisitor、代码生成 CodeGeneratingVisitor、代码美化 PrettyPrintVisitor）。访问者模式允许你将每个操作定义为一个访问者类，从而避免将这些操作分散在每个节点类里。
​​适用情况​​：
一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。
需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。








-----------------------------------------------------------------------------------------------------------



​1. 数字泥团（Data Clumps）​​
​​实例​​：
​​用户地址信息​​：多个地方都出现 String street, String city, String postalCode这三个字段的组合，比如在订单处理、用户注册、物流配送等模块中。每次修改地址格式（比如增加 country）都需要修改多处代码。
​​坐标点​​：多个地方传递 double x, double y，而不是封装成一个 Point类。
​​适用情况​​：
多个数据项总是同时出现（如 width和 height、startDate和 endDate）。
修改其中一个数据项时，其他相关数据项也需要同步修改。
代码中频繁出现相同的一组参数传递。
​​修复方法​​：
将这些数据项封装成一个类（如 Address、Point）。
用对象代替分散的参数，减少重复代码。
​​2. 魔鬼数字（Magic Number）​​
​​实例​​：
if (status == 1)，但 1代表什么？是“已支付”还是“未支付”？
double area = 3.14159 * radius * radius，3.14159应该替换为 Math.PI。
​​适用情况​​：
代码中直接使用没有解释的数字或字符串常量。
数字的含义不直观，需要注释才能理解。
​​修复方法​​：
用有意义的常量或枚举代替，例如：

public static final int STATUS_PAID = 1;
if (status == STATUS_PAID) { ... }


或使用枚举：

enum OrderStatus { PAID, UNPAID, CANCELLED }


​​3. 基本类型偏执（Primitive Obsession）​​
​​实例​​：
用 String表示电话号码，但没有校验逻辑（如长度、格式）。
用 int表示温度，但无法区分摄氏度和华氏度。
​​适用情况​​：
基本类型无法表达业务含义（如“电话号码”不是普通的字符串）。
需要对基本类型添加校验、转换或计算逻辑。
​​修复方法​​：
用自定义类封装基本类型，例如：

class PhoneNumber { 
    private String value;
    public PhoneNumber(String value) { 
        if (!isValid(value)) throw new IllegalArgumentException();
        this.value = value;
    }
}


​​4. 过长参数列表（Long Parameter List）​​
​​实例​​：

public void createUser(String name, String email, String phone, 
                       String address, String gender, int age, 
                       boolean isVIP, LocalDate registerDate) { ... }


​​适用情况​​：
函数参数超过 3~4 个，且部分参数总是同时出现。
调用函数时需要传递大量默认值（如 null或 false）。
​​修复方法​​：
将相关参数封装成对象（如 UserInfo）。
使用 Builder 模式或参数对象：

public void createUser(UserInfo userInfo) { ... }


​​5. 发散式变化（Divergent Change）​​
​​实例​​：
Order类因为不同的原因被修改：
修改支付逻辑时要改 Order。
修改物流逻辑时也要改 Order。
​​适用情况​​：
一个类因为不同的需求频繁被修改，且修改点不相关。
​​修复方法​​：
拆分职责，比如将支付逻辑移到 PaymentService，物流逻辑移到 ShippingService。
​​6. 散弹式修改（Shotgun Surgery）​​
​​实例​​：
添加一个新功能（如“折扣计算”）需要修改 Order、Payment、Invoice等多个类。
​​适用情况​​：
一个功能变更涉及多个类的修改。
​​修复方法​​：
将相关逻辑集中到一个类中（如 DiscountCalculator）。
​​7. 夸夸其谈未来性（Speculative Generality）​​
​​实例​​：

interface Animal { void eat(); void sleep(); void fly(); }  
class Dog implements Animal { 
    public void fly() { throw new UnsupportedOperationException(); } 
}


​​适用情况​​：
代码中充满了“未来可能用到”的抽象或预留的钩子，但实际从未使用。
​​修复方法​​：
按需设计，避免过度抽象。
等真正需要时再扩展（YAGNI 原则：You Aren’t Gonna Need It）。
​​8. 依恋情节（Feature Envy）​​
​​实例​​：

// 计算订单总价时，频繁调用其他类的get方法
public double calculateTotalPrice(Order order) {
    return order.getItems().stream()
               .mapToDouble(item -> item.getPrice() * item.getQuantity())
               .sum() + order.getTax() - order.getDiscount();
}


​​适用情况​​：
一个函数大量调用另一个对象的 getter 方法。
​​修复方法​​：
将逻辑移到数据所在的类（如 order.calculateTotalPrice()）。
​​9. 令人迷惑的临时字段（Temporary Field）​​
​​实例​​：

class User {
    private String name;
    private String email;
    private String temporaryPassword; // 仅在密码重置时使用
}


​​适用情况​​：
某些字段仅在特定场景下使用，其他时候为 null或无意义。
​​修复方法​​：
用参数传递或提取到新类（如 PasswordResetContext）。
​​10. 纯数据类（Data Class）​​
​​实例​​：

class User {
    public String name;
    public int age;
    // 只有getter/setter，没有业务逻辑
}


​​适用情况​​：
类仅包含数据字段和简单的 getter/setter。
​​修复方法​​：
将相关操作封装到类中（如 user.isAdult()）。
​​11. 过度耦合的消息链（Message Chains）​​
​​实例​​：

String city = user.getAddress().getCity().toUpperCase();


​​适用情况​​：
调用链过长（如 a.getB().getC().getD()）。
链中任一对象为 null会导致崩溃。
​​修复方法​​：
封装中间步骤（如 user.getCity()）。
使用 Null 对象模式或 Optional。
​​12. 过多的注释（Excessive Comments）​​
​​实例​​：

// 检查用户是否成年
if (user.age >= 18) { ... }  // 注释是多余的


​​适用情况​​：
注释解释的是代码本身已经表达的内容。
​​修复方法​​：
用清晰的代码代替注释（如 if (user.isAdult())）。
​​13. 混乱的代码层次调用（Broken Layered Architecture）​​
​​实例​​：
Controller 直接调用 DAO 访问数据库，绕过了 Service 层。
Service 层直接处理 HTTP 请求，而不是由 Controller 负责。
​​适用情况​​：
代码层级职责混乱（如业务逻辑漏到 Controller 或 DAO 中）。
​​修复方法​​：
明确分层：Controller → Service → DAO。
禁止跨层调用（如 Controller 不能直接访问 DAO）。
